

## üìä User Metrics API ‚Äì Backend Developer Challenge

This project is a robust, scalable RESTful API designed to serve user metrics, supporting secure access, performance, and realistic cloud architecture strategies. It's built with a production-oriented mindset, prioritizing clean code, modular structure, observability, and extensibility.

---

### üß≠ Project Overview

| Feature                  | Status                       |
| ------------------------ | ---------------------------- |
| RESTful Metrics Endpoint | ‚úÖ Implemented                |
| JWT Authentication       | ‚úÖ Secure and Validated       |
| Rate Limiting            | ‚úÖ Redis-based, Request-aware |
| Caching                  | ‚úÖ Redis with dynamic TTL     |
| Mock Data                | ‚úÖ Seeded in DynamoDB         |
| Data Aggregation         | ‚úÖ Implemented and formatted  |
| Dockerized Architecture  | ‚úÖ Fully containerized        |
| OpenSearch               | ‚úÖ Integrated and ready       |
| Infrastructure as Code   | ‚úÖ Terraform support          |
| Observability            | ‚úÖ Prometheus + Grafana       |

---

## üóÇ Project Structure

```text
user-metrics-api/
‚îÇ
‚îú‚îÄ‚îÄ app/                            # Domain & Application Logic
‚îÇ   ‚îú‚îÄ‚îÄ domain/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ entities.py             # Data models (UserMetrics, PieChartItem)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ exceptions.py          # Custom exceptions (e.g. MetricsNotFoundError)
‚îÇ   ‚îú‚îÄ‚îÄ use_cases/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ metrics_interactor.py   # Business logic (uses repository + presenter + cache)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ metrics_interface.py    # Clean Architecture ports/interfaces
‚îÇ
‚îú‚îÄ‚îÄ infrastructure/                # External service adapters
‚îÇ   ‚îú‚îÄ‚îÄ api/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ routes.py              # FastAPI routes
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ dependencies.py        # Dependency injection
‚îÇ   ‚îú‚îÄ‚îÄ auth/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ jwt_handler.py         # JWT validation logic
‚îÇ   ‚îú‚îÄ‚îÄ cache/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ redis_cache.py         # Async Redis caching
‚îÇ   ‚îú‚îÄ‚îÄ database/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ dynamodb_repository.py # MetricsRepository implementation
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ seed_dynamodb.py       # Local seeding script for DynamoDB
‚îÇ   ‚îú‚îÄ‚îÄ rate_limit/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ limiter.py             # Redis-based rate limiter
‚îÇ   ‚îú‚îÄ‚îÄ search/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ opensearch_publisher.py# OpenSearch integration (future logs/metrics)
‚îÇ
‚îú‚îÄ‚îÄ terraform/                     # IaC (VPC, DynamoDB, Redis, OpenSearch, IAM)
‚îÇ
‚îú‚îÄ‚îÄ docker/
‚îÇ   ‚îî‚îÄ‚îÄ Dockerfile                 # Python Docker build
‚îÇ
‚îú‚îÄ‚îÄ docker-compose.yml            # Multi-service container orchestration
‚îú‚îÄ‚îÄ .env                          # Environment variables
‚îú‚îÄ‚îÄ requirements.txt              # Python dependencies
‚îî‚îÄ‚îÄ main.py                       # FastAPI entrypoint
```

---

## üîê Authentication & Security

* **JWT Auth**: All endpoints are protected using JWT Bearer Tokens.

  * Tokens are decoded with `python-jose`.
  * Malformed or missing tokens result in `403 Forbidden`.
* **Authorization**: User `user_id` is validated against the token's `sub` field.
* **Rate Limiting**: Implemented using Redis keys with TTL (per-user/request path).
* **Replay Protection**: Token signature and structure is strictly verified.

---

## üöÄ API Reference

#### `GET /api/v1/users/{user_id}/metrics`

> Requires Authorization Header: `Bearer <JWT>`

**Response:**

```json
{
  "userId": "1",
  "metrics": {
    "sharesCount": 13,
    "likeCount": 67,
    "positiveCommentCount": 4
  },
  "chartData": {
    "pieChart": [
      {"category": "sweet", "value": 2, "percentage": 50.0},
      {"category": "spicy", "value": 2, "percentage": 50.0}
    ]
  },
  "lastUpdated": "2025-07-09T18:42:00Z"
}
```

---

## üßÆ Data Aggregation

* Likes and shares are summed from seeded posts per user.
* Positive comments are filtered by `"sentiment": "positive"`.
* Pie chart is generated by flavor/category distribution based on mock dataset.
* All aggregations are memoized via Redis cache for 60s TTL.

---

## ‚öôÔ∏è Performance & Scalability Strategies

| Technique          | Description                                       |
| ------------------ | ------------------------------------------------- |
| Redis Cache        | Avoids repeated aggregation for frequent requests |
| Async IO           | FastAPI + Redis client are fully async            |
| OpenSearch         | Prepared for distributed search of metrics        |
| Rate Limiting      | Prevents abusive requests                         |
| Clean Architecture | Easy to scale components independently            |

---

## üß™ Local Setup

1. **Install Docker + Docker Compose**
2. **Clone and run:**

```bash
git clone git@github.com:sarasouza18/MetricsApi.git
cd MetricsApi
docker-compose -f docker/docker-compose.yml up --build
```

3. **Test endpoint with token:**

```bash
curl -X GET http://localhost:8000/api/v1/users/1/metrics \
     -H "Authorization: Bearer <your-valid-token>"
```

---

## üß± Infrastructure as Code (Terraform)

This project supports production deployment on AWS using Terraform:

* `terraform/redis.tf`: ElastiCache Redis cluster
* `terraform/dynamo.tf`: DynamoDB table definition
* `terraform/opensearch.tf`: OpenSearch domain
* `terraform/iam.tf`: Policies + roles
* `terraform/network.tf`: VPC, subnets, security groups

To provision:

```bash
cd terraform
terraform init
terraform apply
```

---

## üì° OpenSearch Integration

* `infrastructure/search/opensearch_publisher.py` contains setup for sending metrics to OpenSearch.
* Future enhancement: stream metrics updates to OpenSearch using SQS or EventBridge.
* Can support dashboards, alerting, or fine-grained analytics.

---

## üõ° JWT Implementation

```python
from jose import JWTError, jwt
from fastapi import HTTPException
# Decodes token and extracts the "sub" as user_id
def validate_token(token: str) -> str:
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=["HS256"])
        user_id = payload.get("sub")
        if user_id is None:
            raise HTTPException(status_code=403, detail="Missing user_id in token")
        return user_id
    except JWTError:
        raise HTTPException(status_code=403, detail="Invalid token")
```

---

## üìò Production Recommendations

* Use **AWS Lambda + API Gateway** for scalability
* Store data in **DynamoDB with Global Secondary Indexes**
* Aggregate heavy metrics using **OpenSearch Dashboards**
* Replace Redis local with **ElastiCache Redis**
* Monitor usage with **CloudWatch** and export metrics to **Grafana**


---

## üìÑ License

MIT License ‚Äì ¬© 2025 Sara Souza
